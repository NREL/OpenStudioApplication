/***********************************************************************************************************************
*  OpenStudio(R), Copyright (c) 2008-2019, Alliance for Sustainable Energy, LLC, and other contributors. All rights reserved.
*
*  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
*  following conditions are met:
*
*  (1) Redistributions of source code must retain the above copyright notice, this list of conditions and the following
*  disclaimer.
*
*  (2) Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following
*  disclaimer in the documentation and/or other materials provided with the distribution.
*
*  (3) Neither the name of the copyright holder nor the names of any contributors may be used to endorse or promote products
*  derived from this software without specific prior written permission from the respective party.
*
*  (4) Other than as required in clauses (1) and (2), distributions in any form of modifications or other derivative works
*  may not use the "OpenStudio" trademark, "OS", "os", or any other confusingly similar designation without specific prior
*  written permission from Alliance for Sustainable Energy, LLC.
*
*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER(S) AND ANY CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
*  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
*  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER(S), ANY CONTRIBUTORS, THE UNITED STATES GOVERNMENT, OR THE UNITED
*  STATES DEPARTMENT OF ENERGY, NOR ANY OF THEIR EMPLOYEES, BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
*  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
*  USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
*  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
*  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
***********************************************************************************************************************/

#include <utilities/OpenStudioApplicationPathHelpers.hpp>

// Include the core one as well
#include <openstudio/utilities/core/PathHelpers.hpp>
#include <openstudio/utilities/core/Logger.hpp>
#include <openstudio/OpenStudio.hxx>

#include <sstream>
#include <boost/regex.hpp>
#include <boost/algorithm/string.hpp>
#include <boost/algorithm/string/case_conv.hpp>
#include <iostream>

#if defined _WIN32
#include <windows.h>
#else
#include <stdio.h>
#include <dlfcn.h>
#endif


namespace openstudio {

  openstudio::path getOpenStudioApplicationSourceDirectory() {
    return openstudio::toPath("${CMAKE_SOURCE_DIR}");
  }

  openstudio::path getOpenStudioApplicationBuildDirectory() {
    return openstudio::toPath("${CMAKE_BINARY_DIR}");
  }

  openstudio::path getOpenStudioApplicationPath() {

    #if defined _WIN32
      TCHAR szPath[MAX_PATH];
      if( GetModuleFileName( nullptr, szPath, MAX_PATH ) ) {
        LOG_FREE(Debug, "OpenStudioApplicationPathHelpers", "getOpenStudioApplicationPath, szPath = '" << szPath << "'");
        return completeAndNormalize(toPath(szPath));
      }
    #else
      Dl_info info;
      if (dladdr("main", &info)) {
        LOG_FREE(Debug, "OpenStudioApplicationPathHelpers", "getOpenStudioApplicationPath, info.dli_fname = '" << info.dli_fname << "'");
        return completeAndNormalize(toPath(info.dli_fname));
      }
    #endif

    return openstudio::path();
  }

  openstudio::path getOpenStudioApplicationDirectory() {
    openstudio::path p = getOpenStudioApplicationPath();
    if (!p.empty()){
      return p.parent_path();
    }
    return openstudio::path();
  }

  bool isOpenStudioApplicationRunningFromBuildDirectory()
  {
#ifdef _WIN32
    openstudio::path buildDir = openstudio::toPath(boost::algorithm::to_upper_copy(openstudio::toString(getOpenStudioApplicationBuildDirectory())));
    openstudio::path runDir = openstudio::toPath(boost::algorithm::to_upper_copy(openstudio::toString(getOpenStudioApplicationDirectory())));
#else
    openstudio::path buildDir = getOpenStudioApplicationBuildDirectory();
    openstudio::path runDir = getOpenStudioApplicationDirectory();
#endif

    return pathBeginsWith(buildDir, runDir);
  }

  // define the function GetCurrentOpenStudioApplicationModule so we can get its address
  #if defined _WIN32
  HMODULE GetCurrentOpenStudioApplicationModule()
  {
      HMODULE hModule = NULL;
      // hModule is NULL if GetModuleHandleEx fails.
      GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS
                          | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
                          (LPCTSTR)GetCurrentOpenStudioApplicationModule, &hModule);
      return hModule;
  }
  #else
  bool GetCurrentOpenStudioApplicationModule()
  {
    return true;
  }
  #endif

  openstudio::path getOpenStudioApplicationModule()
  {
    openstudio::path openstudioDirPath;
    #if defined _WIN32
      TCHAR szPath[MAX_PATH];
      if( GetModuleFileName( GetCurrentOpenStudioApplicationModule(), szPath, MAX_PATH ) ) {
        LOG_FREE(Debug, "OpenStudioApplicationPathHelpers", "getOpenStudioApplicationModule, szPath = '" << szPath << "'");
        openstudioDirPath = completeAndNormalize(toPath(szPath));
      }
    #else
      Dl_info info;
      if (dladdr("GetCurrentOpenStudioApplicationModule", &info)) {
        LOG_FREE(Debug, "OpenStudioApplicationPathHelpers", "getOpenStudioApplicationModule, info.dli_fname = '" << info.dli_fname << "'");
        auto path = toPath(info.dli_fname);
        if ( path.parent_path().empty() ) {
          std::istringstream pathstream( getenv("PATH") );
          std::string pathstring;
          while ( std::getline(pathstream, pathstring, ':') ) {
            LOG_FREE(Debug, "OpenStudioApplicationPathHelpers", "getOpenStudioApplicationModule, searching for '" << path << "' in '" << pathstring << "'");
            auto maybepath = toPath(pathstring) / path;
            if( openstudio::filesystem::exists( maybepath ) && !openstudio::filesystem::is_directory( maybepath ) ) {
              openstudioDirPath = completeAndNormalize(maybepath);
              break;
            }
          }
        } else {
            openstudioDirPath = completeAndNormalize(path);
        }
      }
    #endif
    LOG_FREE(Debug, "OpenStudioApplicationPathHelpers", "getOpenStudioApplicationModule, found '" << openstudioDirPath << "'");
    return openstudioDirPath;
  }

  openstudio::path getOpenStudioApplicationModuleDirectory()
  {
    return getOpenStudioApplicationModule().parent_path();
  }

  bool isOpenStudioApplicationModuleRunningFromBuildDirectory()
  {
#ifdef _WIN32
    openstudio::path buildDir = openstudio::toPath(boost::algorithm::to_upper_copy(openstudio::toString(getOpenStudioApplicationBuildDirectory())));
    openstudio::path runDir = openstudio::toPath(boost::algorithm::to_upper_copy(openstudio::toString(getOpenStudioApplicationModuleDirectory())));
#else
    openstudio::path buildDir = getOpenStudioApplicationBuildDirectory();
    openstudio::path runDir = getOpenStudioApplicationModuleDirectory();
#endif

    return pathBeginsWith(buildDir, runDir);
  }

  openstudio::path getOpenStudioCoreCLI(){
    openstudio::path cliPath;

    // Windows
    // . ( build )
    // ├── Products
    // │   ├── Debug
    // │   │   └── OpenStudioApp
    // │   └── Release
    // │       └── OpenStudioApp
    // openstudio (core build)
    // ├── Products
    // │   ├── ruby
    // │   │   ├── Debug
    // │   │   │   └── openstudio.lib
    // │   │   └── Release
    // │   │       └── openstudio.lib
    // │   ├── Debug
    // │   │   └── openstudio
    // │   ├── Release
    // │   │   └── openstudio

    // Unix
    // . ( build )
    // ├── Products
    // │   ├── OpenStudioApp
    // openstudio (core build)
    // ├── Products
    // │   ├── ruby
    // │   │   └── openstudio.so
    // │   └─── openstudio

    cliPath = getOpenStudioApplicationModuleDirectory() / toPath("${os_cli_install_name}");

    // If it doesn't exist or it's a directory, try the imported location from the sdk
    if (!openstudio::filesystem::exists(cliPath) || openstudio::filesystem::is_directory(cliPath)) {
      cliPath = toPath("${CLI_IMPORTED_PATH}");
    }

    LOG_FREE(Debug, "OpenStudioApplicationPathHelpers", "Searching for CLI in '" << cliPath << "'");
    if( openstudio::filesystem::exists(cliPath) && !openstudio::filesystem::is_directory(cliPath) ){
      LOG_FREE(Debug, "OpenStudioApplicationPathHelpers", "Found CLI at '" << completeAndNormalize(cliPath) << "'");
      return completeAndNormalize(cliPath);
    }

    // Regardless of platform, this is the installed structure
    // . (installed)
    // ├── bin
    // │   ├── OpenStudioApp
    // │   ├── openstudio
    // ├── Ruby
    // │   └── openstudio.so (.lib)

    // If at this point we still haven't found it, assume it's the installed ruby that's used
    #if defined _WIN32
      cliPath = getOpenStudioApplicationModuleDirectory() / toPath("../bin/openstudio.exe");
    #else
      cliPath = getOpenStudioApplicationModuleDirectory() / toPath("../bin/openstudio");
    #endif

    LOG_FREE(Debug, "OpenStudioApplicationPathHelpers", "Searching for CLI in '" << cliPath << "'");
    if( openstudio::filesystem::exists(cliPath) && !openstudio::filesystem::is_directory(cliPath) ){
      LOG_FREE(Debug, "OpenStudioApplicationPathHelpers", "Found CLI at '" << completeAndNormalize(cliPath) << "'");
      return completeAndNormalize(cliPath);
    }

    return openstudio::path();
  }

} // openstudio
